# 程序员的提示工程实战手册

原文：[The Prompt Engineering Playbook for Programmers](https://addyo.substack.com/p/the-prompt-engineering-playbook-for)

## 将 AI 编程助手转变为更可靠的开发伙伴

开发者们正日益依赖 AI 编程助手来加速日常工作流程。这些工具可以自动补全函数、建议错误修复，甚至能生成整个模块或最小可行产品（MVP）。然而，我们中许多人已经体会到，AI 输出的**质量**在很大程度上取决于你提供的**提示词质量**。换言之，**提示工程**已成为一项必备技能。一句措辞不当的请求可能只会得到无关或泛泛的答案，而一个精心设计的提示则能产出深思熟虑、准确甚至富有创意的代码解决方案。本文将从实践角度出发，探讨如何系统地为常见的开发任务构建有效的提示。

AI 结对程序员虽然强大，但并非无所不能——除了你告知或作为上下文包含的信息外，它们对你的具体项目或意图一无所知。你提供的信息越多，输出的效果就越好。我们将提炼出关键的提示模式、**可复用的框架**以及那些在开发者中引起共鸣且易于记忆的例子。你将看到**好提示与坏提示**的并排对比，以及它们得到的真实 AI 回应，并附有评论，以理解为何一个成功而另一个失败。**这是一份快速入门的备忘单：**

## 给 AI 代码助手的提示词技巧

| 技巧 | 提示词模板 | 目的 |
|------|------------|------|
| **1. 角色提示 (Role Prompting)** | "你是一位资深的 **{某种语言}** 开发者。请为了 **{某个目标}** 来审查这个函数。" | 模拟专家级的代码审查、调试或重构，获得更高质量的建议。 |
| **2. 明确上下文 (Explicit Context Setup)** | "问题是：**{问题摘要}**。代码如下。它本应 **{预期行为}**，但现在却 **{实际行为}**。这是为什么？" | 清晰地框定问题，避免 AI 给出泛泛而谈、流于表面的回答。 |
| **3. 输入/输出示例 (Input/Output Examples)** | "当输入为 **{某个输入}** 时，这个函数应该返回 **{预期输出}**。你能编写或修复这段代码吗？" | 通过具体示例来展示你的意图，引导 AI 智能体准确理解需求。 |
| **4. 迭代式链条 (Iterative Chaining)** | "第一步，生成组件的骨架代码。下一步，我们来添加状态管理。最后，处理 API 调用。" | 将复杂的大任务分解成连续的小步骤，避免因提示过于庞大或含糊而导致 AI 混乱。 |
| **5. 模拟调试 (Debug with Simulation)** | "请逐行过一遍这个函数。每个变量的值是什么？代码最有可能在哪里出错？" | 让 AI 智能体模拟代码的运行时行为，从而帮助你发现那些隐藏很深的 bug。 |
| **6. 功能蓝图 (Feature Blueprinting)** | "我正在构建 **{某个功能}**。需求是：**{几点核心需求}**。技术栈是：**{所用技术}**。请搭建出初始组件的脚手架，并解释你的选择。" | 借助 AI 主导的规划和脚手架能力，高效启动新功能的开发。 |
| **7. 重构指导 (Code Refactor Guidance)** | "请重构这段代码以提升 **{某个目标}**，例如 **{可读性、性能、代码风格等}**。请用注释来解释你做了哪些更改。" | 确保 AI 的代码重构与你的核心目标对齐，而不是进行随意的、不必要的修改。 |
| **8. 寻求替代方案 (Ask for Alternatives)** | "你能用函数式风格重写这段代码吗？如果用递归版本会是什么样子？" | 探索多种不同的实现路径，开阔思路，并丰富你的技术工具箱。 |
| **9. 小黄鸭调试法 (Rubber Ducking)** | "我是这样理解这个函数功能的：**{你的解释}**。我有什么遗漏吗？这个解释能暴露出什么 bug 吗？" | 让 AI 扮演"小黄鸭"的角色，通过向它解释来挑战你自己的理解，并发现逻辑上的矛盾之处。 |
| **10. 约束锚定 (Constraint Anchoring)** | "请避免使用 **{例如：递归}**，并严格遵守 **{例如：ES6 语法，不使用外部库}**。请为 **{例如：内存占用}** 进行优化。函数如下：" | 给 AI 设定明确的边界和限制，防止它"自由发挥"过度，或引入与项目不兼容的代码模式。 |

## 高效代码提示的基础

向 AI 编码工具提问，有点像与一个极其刻板、但*有时*知识渊博的合作者沟通。为了得到有用的结果，你需要清晰地设定场景，并引导 AI 明白你*想要什么*以及你*希望它如何做*。

以下是贯穿本手册所有示例的基础原则：

### 1. 提供丰富的上下文

始终假设 AI 对你的项目一无所知，除了你提供的信息。包括相关细节，如编程语言、框架和库，以及具体的函数或代码片段。如果出现错误，请提供确切的错误信息，并描述代码*应该*做什么。**明确性**和**上下文**是区分模糊建议和精确、可操作解决方案的关键。

在实践中，这意味着你的提示可能包含一个简短的背景介绍，例如："我有一个使用 Express 和 Mongoose 的 Node.js 函数，它应该通过 ID 获取用户，但抛出了一个 TypeError。这是代码和错误信息……"。你提供的背景越多，AI 需要猜测的就越少。

### 2. 明确你的目标或问题

模糊的查询导致模糊的答案。与其问"我的代码为什么不工作？"，不如精确指出你需要什么洞见。例如："这个 JavaScript 函数返回了 undefined，而不是预期的结果。根据下面的代码，你能帮忙找出原因并修复吗？"

一个调试的提示公式是：*"它预期会[预期行为]，但在给定[示例输入]时，它却[当前行为]。错误在哪里？"*

同样，如果你想要优化，请要求*特定类型*的优化（例如，*"如何提高这个排序函数处理一万个项目时的运行时性能？"*）。明确性引导 AI 的注意力。

### 3. 分解复杂任务

在实现新功能或处理多步骤问题时，不要把整个问题塞进一个巨大的提示里。将工作分成更小的部分并进行迭代通常更有效。例如，*"首先，为产品列表页面生成一个 React 组件的骨架。接下来，我们添加状态管理。然后，我们再集成 API 调用。"*

每个提示都建立在前一个的基础上。通常不建议一次性要求完成一个大型功能；相反，从一个高层目标开始，然后迭代地要求每个部分。这种方法不仅使 AI 的回应保持专注和可管理，也模仿了人类逐步构建解决方案的方式。

### 4. 包含输入/输出示例或预期行为

如果你能用一个例子来说明你想要什么，就这么做。例如，*"给定数组 [3,1,4]，这个函数应该返回 [1,3,4]。"*

在提示中提供具体例子有助于 AI 理解你的意图并减少歧义。这类似于给一个初级开发者一个快速的测试用例——它澄清了需求。在提示工程术语中，这有时被称为"**少样本提示**（few-shot prompting）"，即你向 AI 展示一个模式让它遵循。即使只有一个正确行为的例子，也能显著地引导模型的响应。

### 5. 利用角色或身份

在许多病毒式传播的提示示例中，一个强大的技巧是要求 AI"扮演"某个特定角色或身份。这可以影响答案的风格和深度。例如，*"扮演一位资深的 React 开发者，审查我的代码中可能存在的错误"*或*"你是一位 JavaScript 性能专家。优化以下函数。"*

通过设定一个角色，你让助手预先进入了相关的状态——无论是成为一个严格的代码审查员，一个帮助初级开发者的老师，还是一个寻找漏洞的安全分析师。

### 6. 迭代并优化对话

提示工程是一个*互动*过程，而非一蹴而就。开发者通常需要审查 AI 的第一个回答，然后提出后续问题或进行修正。如果解决方案不完全正确，你可能会说，*"那个解决方案使用了递归，但我更喜欢迭代的方法——你能不用递归再试一次吗？"*

AI 会记住聊天会话的上下文，所以你可以逐步引导它达到期望的结果。关键在于将 AI 视为一个你可以指导的伙伴——**追求进步而非第一次就完美**。

### 7. 保持代码的清晰和一致性

这最后一个原则有点间接，但对于处理你代码上下文的工具来说非常重要。即使在 AI 介入之前，也要编写清晰、结构良好的代码和注释。有意义的函数和变量名、一致的格式以及文档字符串不仅使你的代码对人类来说更容易理解，也为 AI 提供了更强的线索来了解你在做什么。

如果你展示了一种一致的模式或风格，AI 将会延续它。把这些工具当作极其专注的初级开发者——它们会从你的代码和注释中获取每一个线索。

## 调试代码的提示模式

调试是 AI 助手的天然应用场景。这就像拥有一个不仅会倾听，还会用建议回应你的"小黄鸭"。然而，成功与否很大程度上取决于你如何向 AI 呈现问题。以下是如何系统地为寻求和修复错误提供帮助的提示方法：

### 1. 清晰描述问题和症状

在提示的开头，描述哪里出了问题以及代码应该做什么。始终包含确切的错误信息或不正确的行为。例如，不要只说"我的代码不工作"，你可以这样提示：

*"我有一个 JavaScript 函数，它应该计算一个数字数组的总和，但它返回的是 NaN (Not a Number)，而不是实际的总和。这是代码：[包含代码]。对于像 [1,2,3] 这样的数字数组，它应该输出一个数字（总和），但我得到了 NaN。这个错误的原因可能是什么？"*

这个提示指明了语言、预期行为、观察到的错误输出，并提供了代码上下文——这些都是至关重要的信息。

### 2. 对棘手的错误使用分步或逐行的方法

对于更复杂的逻辑错误（即没有明显错误信息抛出，但输出错误），你可以提示 AI 逐行执行代码。例如：

*"逐行执行这个函数，并跟踪每一步 total 变量的值。它没有正确累加——逻辑错在哪里了？"*

这是一个**小黄鸭调试法提示**的例子——你实际上是要求 AI 模拟人类使用打印语句或调试器进行的调试过程。

### 3. 尽可能提供最小可复现示例

有时你的实际代码库很大，但错误可以在一小段代码中复现。如果你能提取或简化代码并仍然能复现问题，就这么做，并把它提供给 AI。这不仅让 AI 更容易集中注意力，也迫使你澄清问题（这本身就是一个有用的练习）。

### 4. 提出集中的问题和后续追问

提供上下文后，直接询问你需要什么通常很有效，例如：*"可能是什么原因导致了这个问题，我该如何修复？"*

如果 AI 的第一个回答不清楚或只是部分有用，不要犹豫，提出后续问题。

### 调试示例：糟糕的提示 vs. 改进的提示

假设我们有一个简单的 Node.js 函数，旨在将用户对象列表转换为按用户 ID 查找的映射表。然而，它抛出了一个错误。这是有问题的代码：

```javascript
// 有问题的函数：将用户数组转换为按 ID 索引的 map
function mapUsersById(users) {
  const userMap = {};
  for (let i = 0; i <= users.length; i++) {
    // 注意：使用 <= 会在最后一次迭代中越界
    const user = users[i];
    userMap[user.id] = user;
  }
  return userMap;
}

// 示例用法：
const result = mapUsersById([{ id: 1, name: "Alice" }]);
```

❌ **糟糕的提示：**"为什么我的 mapUsersById 函数不工作？"

**AI 对糟糕提示的回应（模拟）：**
> 没有更多信息很难说。你确定函数是用一个合法的用户数组调用的吗？也许问题在于 `users` 是空的或者不是一个数组，导致循环没有正确执行。也可能是设置 `userMap` 属性时出错。请确保每个用户都有一个 `id` 属性。如果 `users` 是 `undefined` 或 `null`，也会导致它不工作。

**分析：** 这个回答相当模糊。提示除了函数名外没有提供任何细节，所以 AI 只能猜测一些常见原因。它没有识别出真正的错误。

✅ **改进的提示：**

"我有一个 JavaScript 函数 `mapUsersById`，它应该将一个用户对象数组转换为一个以用户 ID 为键的 map（对象）。然而，当我运行它时，它抛出了一个错误。例如，当我传入 `[ {id: 1, name: "Alice"} ]` 时，我得到 `TypeError: Cannot read property 'id' of undefined`。这是函数代码：

```javascript
function mapUsersById(users) {
  const userMap = {};
  for (let i = 0; i <= users.length; i++) {
    const user = users[i];
    userMap[user.id] = user;
  }
  return userMap;
}
```

它应该返回 `{ "1": {id: 1, name: "Alice"} }`。错误是什么，我该如何修复它？"

**AI 对改进提示的回应（模拟）：**
> 错误 `Cannot read property 'id' of undefined` 表明在某个时刻，`user` 是 `undefined`，然后你试图访问 `user.id`。查看你的循环，问题出在循环边界上。你使用了 `i <= users.length`。如果 `users.length` 是 1（数组中有一个用户），循环会以 `i = 0` 和 `i = 1` 运行。当 `i` 是 1 时，`users[1]` 是 `undefined`（因为数组中唯一的索引是 0）。因此，在那次迭代中 `user` 变为 `undefined`，而 `user.id` 抛出了一个 TypeError。修复方法是将循环条件改为 `i < users.length`。

**分析：** 这个回应直接指出了错误并解释了为什么这会导致问题。改进的提示之所以成功，是因为它遵循了我们的原则：它指明了语言、描述了函数的目的、包含了确切的错误信息和示例输入，甚至提供了相关的代码片段。

### 额外的调试策略

- **询问潜在原因**：如果你真的束手无策，可以稍微扩大问题范围
- **"向小黄鸭提问"**：向 AI 解释你的代码，让它验证或批评你的理解
- **让 AI 创建测试用例**：询问可能让函数崩溃的边缘情况
- **角色扮演代码审查员**：让 AI 扮演审查员角色进行全面分析

## 重构和优化的提示模式

重构代码——在不改变其功能的前提下，使其更清晰、更快或更符合语言习惯——是 AI 助手可以大放异彩的领域。然而，要有效地利用这些知识，**你的提示必须阐明"更好"对你的情况意味着什么**。

### 1. 明确陈述你的重构目标

单独的"重构这段代码"太开放了。你是想提高可读性？降低复杂性？优化性能？还是使用不同的范式或库？AI 需要一个目标。

一个好的提示会框定任务，例如：
- *"重构以下函数以提高其可读性和可维护性（减少重复，使用更清晰的变量名）。"*
- *"优化这个算法的速度——它在处理大输入时太慢了。"*

### 2. 提供必要的代码上下文

在重构时，你通常会在提示中包含需要改进的代码片段。重要的是要包含你想要重构的完整函数或部分，有时如果相关的话，还包括一些周围的上下文。

同时也要提及语言和框架，因为"符合语言习惯"的代码在不同的环境中是不同的。

### 3. 鼓励在提供代码的同时附上解释

从 AI 主导的重构中学习（并验证其正确性）的一个好方法是要求对更改进行解释。例如：*"请建议一个重构版本的代码，并解释你所做的改进。"*

### 4. 使用角色扮演来设定高标准

要求 AI 扮演代码审查员或高级工程师的角色可能非常有效。对于重构，你可能会说：*"扮演一位经验丰富的 TypeScript 专家，重构这段代码以符合最佳实践和现代标准。"*

### 重构示例：糟糕的提示 vs. 改进的提示

假设我们有一个函数，它进行两次数据库调用并做一些处理。它能工作，但不够美观——有重复的代码，而且难以阅读。

```javascript
// 原始函数：获取两个列表并处理它们（需要重构）
async function getCombinedData(apiClient) {
  // 获取用户列表
  const usersResponse = await apiClient.fetch('/users');
  if (!usersResponse.ok) {
    throw new Error('Failed to fetch users');
  }
  const users = await usersResponse.json();
  
  // 获取订单列表
  const ordersResponse = await apiClient.fetch('/orders');
  if (!ordersResponse.ok) {
    throw new Error('Failed to fetch orders');
  }
  const orders = await ordersResponse.json();
  
  // 合并数据（将用户与订单匹配）
  const result = [];
  for (let user of users) {
    const userOrders = orders.filter(o => o.userId === user.id);
    result.push({ user, orders: userOrders });
  }
  return result;
}
```

❌ **提示 1 (不具体)：**"重构上面的 getCombinedData 函数。"

✅ **提示 2 (目标导向)：**

"重构上面的 getCombinedData 函数以消除重复代码并提高性能。具体来说：
1. 避免重复用户和订单的获取逻辑——也许使用一个辅助函数或将它们一起获取
2. 如果可能，并行获取两个列表
3. 保留每次获取的错误处理（我们想知道是哪个调用失败了）
4. 改进数据合并，可能通过使用更高效的查找结构而不是嵌套循环

提供重构后的代码，并附上解释更改的注释。"

第二个提示会得到更好的结果，因为它明确定义了"重构"的含义和目标。

### 额外的重构技巧

- **分步重构**：如果代码很大，一次只处理一个改进
- **询问替代方法**：探索不同的实现风格
- **结合重构与解释来学习模式**：把 AI 当作学习工具
- **验证和测试**：在任何 AI 生成的重构之后，一定要运行测试

## 实现新功能的提示模式

AI 代码助手最令人兴奋的用途之一是帮助你从头开始编写新代码或将新功能集成到现有代码库中。用于代码生成的提示工程旨在引导 AI 生成符合你需求和风格的代码。

### 1. 从高层指令开始，然后逐步深入

首先用通俗的语言概述你想要构建什么，可能将其分解成更小的任务。例如，假设你想为一个现有的 Web 应用添加一个**搜索栏功能**。你可能首先提示：

*"概述一个计划，在我的 React 应用中添加一个搜索功能，该功能可以按名称过滤产品列表。产品是从一个 API 获取的。"*

一旦你有了这个计划，你就可以用集中的提示来处理每个要点。

### 2. 提供相关上下文或参考代码

如果你要向现有项目添加功能，向 AI 展示该项目中类似功能是如何完成的会非常有帮助。例如：

*"这是一个现有的 UserList 组件（代码…）。现在创建一个类似的 ProductList 组件，但要包括一个搜索栏。"*

### 3. 使用注释和 TODO 作为内联提示

当直接在带有 Copilot 的 IDE 中工作时，一个有效的工作流程是编写一条描述你需要的下一块代码的注释，然后让 AI 自动补全它。

### 4. 提供预期输入/输出或用法的示例

如果你要求 AI 实现一个新函数，请包含一个关于它将如何被使用的快速示例或一个简单的测试用例。

### 5. 当结果不符合你的期望时，用更多细节或约束重写提示

生成新功能的第一次尝试没有成功是很常见的。不要感到沮丧，把 AI 当作一个提交了初稿的初级开发者——现在你需要给出反馈。

### 现代调试场景示例

#### React Hook 依赖问题

❌ **糟糕的提示：** "我的 useEffect 不正常"

✅ **增强的提示：**

```javascript
// 我有一个 React 组件，它获取用户数据，但导致了无限次的重新渲染。这是我的代码：

const UserProfile = ({ userId }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchUser(userId).then(setUser).finally(() => setLoading(false));
  }, [userId, setUser, setLoading]); // 问题在这里

  return loading ? <div>Loading...</div> : <div>{user?.name}</div>;
};
```

**预期行为：** 当 userId 改变时，应该只获取一次用户数据。
**实际行为：** 组件无限次地重新渲染。
**控制台错误：** "Warning: Maximum update depth exceeded"

是什么导致了这个无限循环，我该如何修复依赖数组？

## 常见的提示反模式及其避免方法

并非所有提示都是平等的。认识到**反模式**——那些导致 AI 响应不佳的常见错误——同样具有启发性。

### 常见反模式

1. **模糊的提示**：典型的"它不工作，请修复它"或"写一个做 X 的东西"而没有足够细节
2. **超载的提示**：要求 AI 一次做太多的事情
3. **缺失问题**：提供大量信息但从未清楚地提出问题
4. **模糊的成功标准**：要求优化或改进但没有定义成功是什么样子
5. **忽略 AI 的澄清或输出**：不回答 AI 的澄清问题
6. **风格多变或不一致**：在一次请求中混合不同的格式
7. **模糊的引用**：如"上面的代码"而没有明确指出

### 在事情出错时重写提示的战术方法

1. **识别 AI 响应中缺失或不正确的地方**
2. **在一个新的提示中添加或强调那个要求**
3. **如果需要，进一步分解请求**
4. **如果对话卡住了，考虑重新开始**

## 结论

提示工程既是一门艺术，也是一门科学——正如我们所见，它正迅速成为使用 AI 代码助手的开发者必备的技能。通过精心设计清晰、富含上下文的提示，你实际上是在*教* AI 你需要什么，就像你引导一个新的人类团队成员或向同事解释一个问题一样。

在本文中，我们探讨了如何系统地为调试、重构和功能实现构建提示：

- 我们学会了向 AI 提供与向同事求助时相同的信息：代码应该做什么、它如何行为异常、相关的代码片段等等——从而获得更有针对性的帮助。

- 我们看到了与 AI 迭代的威力，无论是逐行遍历函数逻辑，还是通过多个提示优化解决方案。耐心和迭代将 AI 从一个一次性的代码生成器转变为真正的结对程序员。

- 我们利用角色扮演和身份设定来提升响应的水平——将 AI 视为代码审查员、导师或某个技术栈的专家。

- 对于重构和优化，我们强调了定义"好"的标准，而 AI 也表明，在引导下，它可以应用已知的最佳实践。

- 我们还演示了在 AI 辅助下逐步构建新功能，表明即使是复杂的任务也可以分解并一次一个提示地解决。

当你将这些技巧融入你的工作流程时，你可能会发现与 AI 的合作变得更加直观。你会培养出一种感觉，知道什么样的措辞能得到最好的结果，以及在模型偏离轨道时如何引导它。

请记住，AI 是其训练数据的产物——它看过许多代码和解决问题的例子，但提供方向，指明哪些例子在当下是相关的，这正是*你*的工作。本质上，**你设定上下文，AI 跟进执行**。

**同样值得注意的是，提示工程是一种不断发展的实践。** 开发者社区在不断发现新的技巧。请关注这些讨论，因为它们可以激发你自己的技巧。但也不要害怕自己进行实验。

**总而言之，提示工程使开发者能够从 AI 助手中获得更多。** 这是令人沮丧的体验（"这个工具没用，它给了我一堆胡说八道"）和高效体验（"这感觉就像和一个为我写样板代码的专家结对编程"）之间的区别。

作为最后的总结，请记住**提示是一个迭代的对话**。用你与另一位工程师沟通时所使用的同样清晰、耐心和彻底的态度来对待它。这样做，你会发现 AI 助手可以显著放大你的能力——帮助你更快地调试、更聪明地重构，并更轻松地实现功能。

**祝你提示愉快，编码快乐！**